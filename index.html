<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crypto Price Alert Agent (BTC/ETH) — CoinGecko</title>
  <meta name="description" content="Single-file crypto alert agent that monitors BTC/ETH via CoinGecko every 30s and alerts on >2% moves. 100% client-side, GitHub Pages ready." />
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #111821;
      --subtle: #1a2330;
      --text: #e6eef7;
      --muted: #9db0c7;
      --green: #16a34a;
      --red: #dc2626;
      --amber: #f59e0b;
      --card-radius: 16px;
      --shadow: 0 6px 24px rgba(0,0,0,.35);
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    a { color: #93c5fd; text-decoration: none; }
    a:hover { text-decoration: underline; }

    .container { max-width: 980px; margin: 24px auto; padding: 0 16px; }
    header { display: grid; gap: 8px; margin-bottom: 16px; }
    h1 { font-size: 1.6rem; margin: 0; letter-spacing: .3px; }
    .sub { color: var(--muted); font-size: .95rem; }

    .grid { display: grid; grid-template-columns: 1.2fr .8fr; gap: 16px; }
    @media (max-width: 820px) { .grid { grid-template-columns: 1fr; } }

    .panel { background: linear-gradient(180deg, var(--panel), var(--subtle)); border: 1px solid rgba(255,255,255,.06); border-radius: var(--card-radius); box-shadow: var(--shadow); }
    .panel .inner { padding: 16px; }

    .controls { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
    @media (max-width: 540px){ .controls { grid-template-columns: 1fr; } }

    .control { background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06); border-radius: 12px; padding: 12px; }
    .control label { font-size: .9rem; color: var(--muted); display: block; margin-bottom: 6px; }
    .control input[type="number"], .control select, .control input[type="text"] {
      width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.08); background: #0e141c; color: var(--text);
    }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .chip { display: inline-flex; gap: 8px; align-items: center; background: rgba(255,255,255,.06); padding: 8px 10px; border-radius: 999px; font-size: .9rem; }
    .switch { display: inline-flex; gap: 8px; align-items: center; cursor: pointer; }
    .switch input { transform: scale(1.1); }

    .button { appearance: none; border: 1px solid rgba(255,255,255,.08); background: #0e141c; color: var(--text); padding: 10px 14px; border-radius: 12px; cursor: pointer; transition: .2s; }
    .button:hover { transform: translateY(-1px); }
    .button:active { transform: translateY(0); }
    .button.primary { background: #1f2937; border-color: #334155; }
    .button.green { background: var(--green); border-color: transparent; color: white; }
    .button.red { background: var(--red); border-color: transparent; color: white; }
    .button.ghost { background: transparent; }

    .table { width: 100%; border-collapse: collapse; }
    .table th, .table td { padding: 10px 8px; text-align: left; border-bottom: 1px dashed rgba(255,255,255,.08); }
    .table th { font-weight: 600; color: var(--muted); font-size: .9rem; }
    .price { font-variant-numeric: tabular-nums; font-feature-settings: "tnum" on, "lnum" on; }
    .delta { font-weight: 700; }
    .delta.up { color: var(--green); }
    .delta.down { color: var(--red); }

    .banner { display: none; position: sticky; top: 0; z-index: 50; background: rgba(22, 163, 74, .1); border: 1px solid rgba(22,163,74,.35); color: #c7f9d4; padding: 10px 14px; border-radius: 12px; margin-bottom: 12px; }
    .banner.error { background: rgba(220, 38, 38, .1); border-color: rgba(220,38,38,.35); color: #fecaca; }

    .rowline { display: grid; grid-template-columns: 1fr 1fr 1fr 160px; gap: 8px; align-items: center; }
    @media (max-width: 680px){ .rowline { grid-template-columns: 1fr 1fr; gap: 6px; } .rowline .spark, .rowline .actions { grid-column: span 2; } }

    canvas.spark { width: 100%; height: 40px; background: rgba(255,255,255,.03); border-radius: 6px; display: block; }

    footer { color: var(--muted); margin: 18px 0 48px; font-size: .85rem; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Crypto Price Alert Agent — CoinGecko (BTC/ETH)</h1>
      <div class="sub">100% client‑side. Polls CoinGecko every <span id="pollLabel">30</span>s and alerts on moves &gt; <span id="thLabel">2</span>%. No API key. Ready for GitHub Pages.</div>
    </header>

    <div id="okBanner" class="banner"></div>
    <div id="errBanner" class="banner error"></div>

    <div class="grid">
      <div class="panel">
        <div class="inner">
          <div class="controls">
            <div class="control">
              <label>Coins to monitor</label>
              <div class="row">
                <label class="chip"><input type="checkbox" id="btcOn" checked> BTC</label>
                <label class="chip"><input type="checkbox" id="ethOn" checked> ETH</label>
              </div>
            </div>
            <div class="control">
              <label>Alert threshold (%)</label>
              <input type="number" id="threshold" value="2" min="0.1" step="0.1">
            </div>
            <div class="control">
              <label>Polling interval (seconds)</label>
              <input type="number" id="interval" value="30" min="10" step="5">
            </div>
            <div class="control">
              <label>Baseline behavior</label>
              <div class="row">
                <label class="switch"><input type="checkbox" id="autoReset" checked> Auto‑reset baseline after an alert</label>
              </div>
            </div>
            <div class="control">
              <label>Notifications</label>
              <div class="row">
                <label class="switch"><input type="checkbox" id="soundOn"> Sound</label>
                <label class="switch"><input type="checkbox" id="desktopOn"> Desktop notification</label>
              </div>
            </div>
            <div class="control">
              <label>Controls</label>
              <div class="row">
                <button class="button primary" id="startBtn">▶ Start</button>
                <button class="button ghost" id="stopBtn" disabled>⏸ Stop</button>
                <button class="button" id="resetBaselineBtn">↺ Reset baseline</button>
                <button class="button" id="testUp">Test +3%</button>
                <button class="button" id="testDown">Test −3%</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="inner">
          <table class="table">
            <thead>
              <tr>
                <th>Asset</th>
                <th>Price (USD)</th>
                <th>Change vs. baseline</th>
                <th>Mini chart</th>
              </tr>
            </thead>
            <tbody id="rows">
              <tr>
                <td>BTC</td>
                <td class="price" id="btcPrice">—</td>
                <td class="delta" id="btcDelta">—</td>
                <td class="spark"><canvas id="btcSpark" class="spark" width="200" height="40"></canvas></td>
              </tr>
              <tr>
                <td>ETH</td>
                <td class="price" id="ethPrice">—</td>
                <td class="delta" id="ethDelta">—</td>
                <td class="spark"><canvas id="ethSpark" class="spark" width="200" height="40"></canvas></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <footer>
      <div>Uses <a href="https://www.coingecko.com/en/api/documentation">CoinGecko public API</a>. Data may be delayed. Not financial advice. Page must remain open to monitor.</div>
    </footer>
  </div>

  <script>
  // ======= Beginner-friendly, single-file crypto alert agent =======
  // What it does:
  // - Fetches live BTC/ETH USD prices from CoinGecko every N seconds (default 30s)
  // - Sets a baseline price on first fetch (per coin)
  // - Alerts when price moves by more than the chosen % threshold vs baseline
  // - Optional sound + desktop notifications
  // - Auto-reset baseline after alert (toggleable) to avoid repeated alerts
  // - Simple sparkline chart per coin

  const API_URL = 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd&precision=full';

  // State
  let timer = null;
  const state = {
    coins: {
      bitcoin: { symbol: 'BTC', enabled: true, baseline: null, last: null, history: [] },
      ethereum: { symbol: 'ETH', enabled: true, baseline: null, last: null, history: [] },
    },
    threshold: 2,         // percent
    intervalSec: 30,      // seconds
    autoReset: true,
    soundOn: false,
    desktopOn: false,
  };

  // DOM shortcuts
  const el = id => document.getElementById(id);
  const btcOn = el('btcOn');
  const ethOn = el('ethOn');
  const thresholdInput = el('threshold');
  const intervalInput = el('interval');
  const autoReset = el('autoReset');
  const soundOn = el('soundOn');
  const desktopOn = el('desktopOn');
  const startBtn = el('startBtn');
  const stopBtn = el('stopBtn');
  const resetBaselineBtn = el('resetBaselineBtn');
  const testUpBtn = el('testUp');
  const testDownBtn = el('testDown');
  const okBanner = el('okBanner');
  const errBanner = el('errBanner');
  const pollLabel = el('pollLabel');
  const thLabel = el('thLabel');

  const priceCell = {
    bitcoin: el('btcPrice'),
    ethereum: el('ethPrice'),
  };
  const deltaCell = {
    bitcoin: el('btcDelta'),
    ethereum: el('ethDelta'),
  };
  const sparkCtx = {
    bitcoin: el('btcSpark').getContext('2d'),
    ethereum: el('ethSpark').getContext('2d'),
  };

  // Persist settings across reloads using localStorage
  const saveSettings = () => {
    localStorage.setItem('cpa_settings', JSON.stringify({
      enabled: { bitcoin: state.coins.bitcoin.enabled, ethereum: state.coins.ethereum.enabled },
      threshold: state.threshold,
      intervalSec: state.intervalSec,
      autoReset: state.autoReset,
      soundOn: state.soundOn,
      desktopOn: state.desktopOn,
    }));
  };
  const loadSettings = () => {
    try {
      const raw = localStorage.getItem('cpa_settings');
      if (!raw) return;
      const s = JSON.parse(raw);
      state.threshold = s.threshold ?? state.threshold;
      state.intervalSec = s.intervalSec ?? state.intervalSec;
      state.autoReset = s.autoReset ?? state.autoReset;
      state.soundOn = s.soundOn ?? state.soundOn;
      state.desktopOn = s.desktopOn ?? state.desktopOn;
      state.coins.bitcoin.enabled = s.enabled?.bitcoin ?? true;
      state.coins.ethereum.enabled = s.enabled?.ethereum ?? true;
    } catch (e) {}
  };
  loadSettings();

  // Reflect settings to UI
  const syncUI = () => {
    btcOn.checked = state.coins.bitcoin.enabled;
    ethOn.checked = state.coins.ethereum.enabled;
    thresholdInput.value = state.threshold;
    intervalInput.value = state.intervalSec;
    autoReset.checked = state.autoReset;
    soundOn.checked = state.soundOn;
    desktopOn.checked = state.desktopOn;
    pollLabel.textContent = String(state.intervalSec);
    thLabel.textContent = String(state.threshold);
  };
  syncUI();

  // Helpers
  const fmtUSD = v => {
    if (v == null || isNaN(v)) return '—';
    // Format with more decimals for small values
    const digits = v >= 1000 ? 2 : v >= 10 ? 2 : 4;
    return `$${Number(v).toLocaleString(undefined, { minimumFractionDigits: digits, maximumFractionDigits: digits })}`;
  };
  const fmtPct = v => `${(v >= 0 ? '+' : '')}${v.toFixed(2)}%`;

  // Simple sparkline draw
  function drawSpark(ctx, arr) {
    const W = ctx.canvas.width, H = ctx.canvas.height;
    ctx.clearRect(0,0,W,H);
    if (!arr || arr.length < 2) return;
    const min = Math.min(...arr), max = Math.max(...arr);
    const span = max - min || 1;
    // baseline grid line (last value)
    ctx.globalAlpha = .2; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(W, H/2); ctx.stroke(); ctx.globalAlpha = 1;
    // path
    ctx.beginPath();
    arr.forEach((v,i) => {
      const x = (i/(arr.length-1))*W;
      const y = H - ((v - min)/span)*H;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#93c5fd';
    ctx.stroke();
  }

  // Sound (requires a user gesture to enable on most browsers)
  function beep() {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'triangle'; o.frequency.value = 880; // A5
      o.connect(g); g.connect(ctx.destination); g.gain.value = 0.03;
      o.start(); setTimeout(() => { o.stop(); ctx.close(); }, 250);
    } catch (e) {}
  }

  // Desktop notification
  function notifyDesktop(title, body) {
    if (!state.desktopOn) return;
    if (!('Notification' in window)) return;
    if (Notification.permission === 'granted') {
      new Notification(title, { body });
    }
  }

  function showOk(msg) { okBanner.style.display = 'block'; okBanner.textContent = msg; setTimeout(()=> okBanner.style.display='none', 4000); }
  function showErr(msg) { errBanner.style.display = 'block'; errBanner.textContent = msg; setTimeout(()=> errBanner.style.display='none', 6000); }

  // Core fetch + compare
  async function fetchPrices() {
    const res = await fetch(API_URL, { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  function handleAlert(coinKey, pctChange, cur, base) {
    const c = state.coins[coinKey];
    const dir = pctChange >= 0 ? 'up' : 'down';
    const pretty = `${c.symbol} ${dir === 'up' ? '↑' : '↓'} ${fmtPct(pctChange)}  (${fmtUSD(cur)} vs baseline ${fmtUSD(base)})`;
    // Color the delta cell loudly
    const dcell = deltaCell[coinKey];
    dcell.classList.remove('up','down');
    dcell.classList.add(dir);
    // Sound + desktop + banner
    if (state.soundOn) beep();
    notifyDesktop('Crypto Alert', pretty);
    showOk(pretty);
    if (state.autoReset) {
      c.baseline = cur; // reset to current to avoid immediate re-alert
    }
  }

  async function tick() {
    try {
      const data = await fetchPrices();
      const now = Date.now();
      for (const key of ['bitcoin','ethereum']) {
        const enabled = state.coins[key].enabled;
        const price = data[key]?.usd;
        if (typeof price !== 'number') continue;
        const c = state.coins[key];
        if (!c.baseline) c.baseline = price;
        c.last = price;
        // update history
        c.history.push(price);
        if (c.history.length > 90) c.history.shift();
        // render price & spark
        priceCell[key].textContent = fmtUSD(price);
        drawSpark(sparkCtx[key], c.history);
        // compute change vs baseline if enabled
        const pct = ((price - c.baseline) / c.baseline) * 100;
        const cell = deltaCell[key];
        cell.textContent = fmtPct(pct);
        cell.classList.toggle('up', pct >= 0);
        cell.classList.toggle('down', pct < 0);
        // Alert only if enabled for coin and abs change exceeds threshold
        if (enabled && Math.abs(pct) >= state.threshold) {
          handleAlert(key, pct, price, c.baseline);
        }
      }
    } catch (err) {
      showErr(`Fetch failed: ${err.message}. CoinGecko might be rate-limiting. Retrying…`);
    }
  }

  function start() {
    if (timer) return;
    // Apply current UI settings first
    state.threshold = Number(thresholdInput.value) || 2;
    state.intervalSec = Math.max(10, Number(intervalInput.value) || 30);
    state.autoReset = !!autoReset.checked;
    state.soundOn = !!soundOn.checked;
    state.desktopOn = !!desktopOn.checked;
    state.coins.bitcoin.enabled = !!btcOn.checked;
    state.coins.ethereum.enabled = !!ethOn.checked;
    saveSettings(); syncUI();

    // Ask for notifications permission if toggled on
    if (state.desktopOn && 'Notification' in window && Notification.permission !== 'granted') {
      Notification.requestPermission().then(()=>{});
    }

    // First immediate tick, then set interval
    tick();
    timer = setInterval(tick, state.intervalSec * 1000);
    startBtn.disabled = true; stopBtn.disabled = false;
    showOk(`Monitoring every ${state.intervalSec}s. Alerts on ±${state.threshold}%.`);
  }
  function stop() {
    if (timer) { clearInterval(timer); timer = null; }
    startBtn.disabled = false; stopBtn.disabled = true;
    showOk('Monitoring paused.');
  }
  function resetBaseline() {
    for (const key of ['bitcoin','ethereum']) {
      const c = state.coins[key];
      if (c.last != null) c.baseline = c.last;
    }
    showOk('Baseline reset to current prices.');
  }

  // Test buttons (simulate an alert by nudging baselines)
  function simulate(deltaPct) {
    for (const key of ['bitcoin','ethereum']) {
      const c = state.coins[key];
      if (!c.baseline) continue;
      c.baseline = c.baseline / (1 + deltaPct/100); // so current appears moved by +deltaPct
    }
    tick();
  }

  // Wire events
  startBtn.addEventListener('click', start);
  stopBtn.addEventListener('click', stop);
  resetBaselineBtn.addEventListener('click', resetBaseline);
  testUpBtn.addEventListener('click', () => simulate(+3));
  testDownBtn.addEventListener('click', () => simulate(-3));
  thresholdInput.addEventListener('input', () => { state.threshold = Number(thresholdInput.value)||2; thLabel.textContent = String(state.threshold); saveSettings(); });
  intervalInput.addEventListener('input', () => { state.intervalSec = Math.max(10, Number(intervalInput.value)||30); pollLabel.textContent = String(state.intervalSec); saveSettings(); });
  btcOn.addEventListener('change', () => { state.coins.bitcoin.enabled = !!btcOn.checked; saveSettings(); });
  ethOn.addEventListener('change', () => { state.coins.ethereum.enabled = !!ethOn.checked; saveSettings(); });
  autoReset.addEventListener('change', () => { state.autoReset = !!autoReset.checked; saveSettings(); });
  soundOn.addEventListener('change', () => { state.soundOn = !!soundOn.checked; saveSettings(); if (soundOn.checked) beep(); });
  desktopOn.addEventListener('change', () => { state.desktopOn = !!desktopOn.checked; saveSettings(); if (desktopOn.checked && 'Notification' in window) Notification.requestPermission(); });

  // Optional: auto-start on load for convenience
  window.addEventListener('load', () => {
    // sync UI again in case localStorage changed
    syncUI();
  });
  </script>
</body>
</html>
